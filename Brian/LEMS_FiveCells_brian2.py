'''
Brian simulator compliant Python export for:

Components:
    izTonicSpiking (Type: izhikevichCell:  v0=-0.07 (SI voltage) a=0.02 (dimensionless) b=0.2 (dimensionless) c=-65.0 (dimensionless) d=6.0 (dimensionless) thresh=0.03 (SI voltage) MSEC=0.001 (SI time) MVOLT=0.001 (SI voltage))
    izPhasicSpiking (Type: izhikevichCell:  v0=-0.064 (SI voltage) a=0.02 (dimensionless) b=0.25 (dimensionless) c=-65.0 (dimensionless) d=6.0 (dimensionless) thresh=0.03 (SI voltage) MSEC=0.001 (SI time) MVOLT=0.001 (SI voltage))
    izTonicBursting (Type: izhikevichCell:  v0=-0.07 (SI voltage) a=0.02 (dimensionless) b=0.2 (dimensionless) c=-50.0 (dimensionless) d=2.0 (dimensionless) thresh=0.03 (SI voltage) MSEC=0.001 (SI time) MVOLT=0.001 (SI voltage))
    izPhasicBursting (Type: izhikevichCell:  v0=-0.064 (SI voltage) a=0.02 (dimensionless) b=0.25 (dimensionless) c=-55.0 (dimensionless) d=0.05 (dimensionless) thresh=0.03 (SI voltage) MSEC=0.001 (SI time) MVOLT=0.001 (SI voltage))
    izMixedMode (Type: izhikevichCell:  v0=-0.07 (SI voltage) a=0.02 (dimensionless) b=0.2 (dimensionless) c=-55.0 (dimensionless) d=4.0 (dimensionless) thresh=0.03 (SI voltage) MSEC=0.001 (SI time) MVOLT=0.001 (SI voltage))
    iA (Type: pulseGeneratorDL:  delay=0.01 (SI time) duration=0.09 (SI time) amplitude=14.0 (dimensionless))
    iB (Type: pulseGeneratorDL:  delay=0.02 (SI time) duration=0.18 (SI time) amplitude=0.5 (dimensionless))
    iC (Type: pulseGeneratorDL:  delay=0.022 (SI time) duration=0.198 (SI time) amplitude=15.0 (dimensionless))
    iD (Type: pulseGeneratorDL:  delay=0.02 (SI time) duration=0.18 (SI time) amplitude=0.6 (dimensionless))
    iE (Type: pulseGeneratorDL:  delay=0.016 (SI time) duration=0.14400000000000002 (SI time) amplitude=10.0 (dimensionless))
    net1 (Type: network)
    sim1 (Type: Simulation:  length=0.22 (SI time) step=1.0E-5 (SI time))

'''
'''
    This Brian file has been generated by org.neuroml.export (see https://github.com/NeuroML/org.neuroml.export)
         org.neuroml.export  v1.9.0
         org.neuroml.model   v1.9.0
         jLEMS               v0.10.7
'''
from brian2 import *

from math import *
import sys

import numpy as np


if len(sys.argv) > 1 and sys.argv[1] == '-nogui':
    show_gui = False
else:
    show_gui = True

# Adding simulation Component(id=sim1 type=Simulation) of network: net1 (Type: network)

defaultclock.dt = 0.01*msecond
duration = 220.0*msecond
steps = int(duration/defaultclock.dt)+1

#    Population popA contains components of: Component(id=izTonicSpiking type=izhikevichCell) 

izTonicSpiking_eqs=Equations('''
    dv/dt = ((((0.04 * ((v ** 2.0) / MVOLT)) + (5.0 * v)) + (((140.0 - U) + ISyn) * MVOLT)) / MSEC) :  volt
    dU/dt = (a * (((b * (v / MVOLT)) - U) / MSEC)) :  1
    MSEC = 0.001 * second : second 
    MVOLT = 0.001 * volt : volt 
    v0 = -0.07 * volt : volt 
    a = 0.02: 1 
    b = 0.2: 1 
    c = -65.0: 1 
    d = 6.0: 1 
    thresh = 0.03 * volt : volt 
    ISyn = popA_ISyn(t) :  1
''')

popA = NeuronGroup(1, model=izTonicSpiking_eqs, threshold = 'v > thresh', reset = """v = c * MVOLT
U = U + d""")
popA.v = popA.v0
popA.U = ( popA.v0  * ( popA.b  /  popA.MVOLT ))
# Initialise a second time...
popA.v = popA.v0
popA.U = ( popA.v0  * ( popA.b  /  popA.MVOLT ))
#    Population popB contains components of: Component(id=izPhasicSpiking type=izhikevichCell) 

izPhasicSpiking_eqs=Equations('''
    dv/dt = ((((0.04 * ((v ** 2.0) / MVOLT)) + (5.0 * v)) + (((140.0 - U) + ISyn) * MVOLT)) / MSEC) :  volt
    dU/dt = (a * (((b * (v / MVOLT)) - U) / MSEC)) :  1
    MSEC = 0.001 * second : second 
    MVOLT = 0.001 * volt : volt 
    v0 = -0.064 * volt : volt 
    a = 0.02: 1 
    b = 0.25: 1 
    c = -65.0: 1 
    d = 6.0: 1 
    thresh = 0.03 * volt : volt 
    ISyn = popB_ISyn(t) :  1
''')

popB = NeuronGroup(1, model=izPhasicSpiking_eqs, threshold = 'v > thresh', reset = """v = c * MVOLT
U = U + d""")
popB.v = popB.v0
popB.U = ( popB.v0  * ( popB.b  /  popB.MVOLT ))
# Initialise a second time...
popB.v = popB.v0
popB.U = ( popB.v0  * ( popB.b  /  popB.MVOLT ))
#    Population popC contains components of: Component(id=izTonicBursting type=izhikevichCell) 

izTonicBursting_eqs=Equations('''
    dv/dt = ((((0.04 * ((v ** 2.0) / MVOLT)) + (5.0 * v)) + (((140.0 - U) + ISyn) * MVOLT)) / MSEC) :  volt
    dU/dt = (a * (((b * (v / MVOLT)) - U) / MSEC)) :  1
    MSEC = 0.001 * second : second 
    MVOLT = 0.001 * volt : volt 
    v0 = -0.07 * volt : volt 
    a = 0.02: 1 
    b = 0.2: 1 
    c = -50.0: 1 
    d = 2.0: 1 
    thresh = 0.03 * volt : volt 
    ISyn = popC_ISyn(t) :  1
''')

popC = NeuronGroup(1, model=izTonicBursting_eqs, threshold = 'v > thresh', reset = """v = c * MVOLT
U = U + d""")
popC.v = popC.v0
popC.U = ( popC.v0  * ( popC.b  /  popC.MVOLT ))
# Initialise a second time...
popC.v = popC.v0
popC.U = ( popC.v0  * ( popC.b  /  popC.MVOLT ))
#    Population popD contains components of: Component(id=izPhasicBursting type=izhikevichCell) 

izPhasicBursting_eqs=Equations('''
    dv/dt = ((((0.04 * ((v ** 2.0) / MVOLT)) + (5.0 * v)) + (((140.0 - U) + ISyn) * MVOLT)) / MSEC) :  volt
    dU/dt = (a * (((b * (v / MVOLT)) - U) / MSEC)) :  1
    MSEC = 0.001 * second : second 
    MVOLT = 0.001 * volt : volt 
    v0 = -0.064 * volt : volt 
    a = 0.02: 1 
    b = 0.25: 1 
    c = -55.0: 1 
    d = 0.05: 1 
    thresh = 0.03 * volt : volt 
    ISyn = popD_ISyn(t) :  1
''')

popD = NeuronGroup(1, model=izPhasicBursting_eqs, threshold = 'v > thresh', reset = """v = c * MVOLT
U = U + d""")
popD.v = popD.v0
popD.U = ( popD.v0  * ( popD.b  /  popD.MVOLT ))
# Initialise a second time...
popD.v = popD.v0
popD.U = ( popD.v0  * ( popD.b  /  popD.MVOLT ))
#    Population popE contains components of: Component(id=izMixedMode type=izhikevichCell) 

izMixedMode_eqs=Equations('''
    dv/dt = ((((0.04 * ((v ** 2.0) / MVOLT)) + (5.0 * v)) + (((140.0 - U) + ISyn) * MVOLT)) / MSEC) :  volt
    dU/dt = (a * (((b * (v / MVOLT)) - U) / MSEC)) :  1
    MSEC = 0.001 * second : second 
    MVOLT = 0.001 * volt : volt 
    v0 = -0.07 * volt : volt 
    a = 0.02: 1 
    b = 0.2: 1 
    c = -55.0: 1 
    d = 4.0: 1 
    thresh = 0.03 * volt : volt 
    ISyn = popE_ISyn(t) :  1
''')

popE = NeuronGroup(1, model=izMixedMode_eqs, threshold = 'v > thresh', reset = """v = c * MVOLT
U = U + d""")
popE.v = popE.v0
popE.U = ( popE.v0  * ( popE.b  /  popE.MVOLT ))
# Initialise a second time...
popE.v = popE.v0
popE.U = ( popE.v0  * ( popE.b  /  popE.MVOLT ))


# Inputs
#    Input iA on pop: popA: iA (Type: pulseGeneratorDL:  delay=0.01 (SI time) duration=0.09 (SI time) amplitude=14.0 (dimensionless))
popA_ISyn = TimedArray( np.concatenate( ( 
         np.repeat(0, int(0.01/defaultclock.dt)) , 
         np.repeat(14.0, int(0.09/defaultclock.dt)) , 
         np.repeat(0, (steps - int(0.1/defaultclock.dt))) ) ) * 1 , 
         dt=defaultclock.dt)

#    Input iB on pop: popB: iB (Type: pulseGeneratorDL:  delay=0.02 (SI time) duration=0.18 (SI time) amplitude=0.5 (dimensionless))
popB_ISyn = TimedArray( np.concatenate( ( 
         np.repeat(0, int(0.02/defaultclock.dt)) , 
         np.repeat(0.5, int(0.18/defaultclock.dt)) , 
         np.repeat(0, (steps - int(0.2/defaultclock.dt))) ) ) * 1 , 
         dt=defaultclock.dt)

#    Input iC on pop: popC: iC (Type: pulseGeneratorDL:  delay=0.022 (SI time) duration=0.198 (SI time) amplitude=15.0 (dimensionless))
popC_ISyn = TimedArray( np.concatenate( ( 
         np.repeat(0, int(0.022/defaultclock.dt)) , 
         np.repeat(15.0, int(0.198/defaultclock.dt)) , 
         np.repeat(0, (steps - int(0.22/defaultclock.dt))) ) ) * 1 , 
         dt=defaultclock.dt)

#    Input iD on pop: popD: iD (Type: pulseGeneratorDL:  delay=0.02 (SI time) duration=0.18 (SI time) amplitude=0.6 (dimensionless))
popD_ISyn = TimedArray( np.concatenate( ( 
         np.repeat(0, int(0.02/defaultclock.dt)) , 
         np.repeat(0.6, int(0.18/defaultclock.dt)) , 
         np.repeat(0, (steps - int(0.2/defaultclock.dt))) ) ) * 1 , 
         dt=defaultclock.dt)

#    Input iE on pop: popE: iE (Type: pulseGeneratorDL:  delay=0.016 (SI time) duration=0.14400000000000002 (SI time) amplitude=10.0 (dimensionless))
popE_ISyn = TimedArray( np.concatenate( ( 
         np.repeat(0, int(0.016/defaultclock.dt)) , 
         np.repeat(10.0, int(0.144/defaultclock.dt)) , 
         np.repeat(0, (steps - int(0.16/defaultclock.dt))) ) ) * 1 , 
         dt=defaultclock.dt)


if show_gui:

    # Display: Component(id=A type=Display)
    trace_A__iz1 = StateMonitor(popA,'v',record=[0]) # iz1 (Type: Line:  scale=0.001 (dimensionless) timeScale=0.001 (dimensionless))

    # Display: Component(id=B type=Display)
    trace_B__iz1 = StateMonitor(popB,'v',record=[0]) # iz1 (Type: Line:  scale=0.001 (dimensionless) timeScale=0.001 (dimensionless))

    # Display: Component(id=C type=Display)
    trace_C__iz1 = StateMonitor(popC,'v',record=[0]) # iz1 (Type: Line:  scale=0.001 (dimensionless) timeScale=0.001 (dimensionless))

    # Display: Component(id=D type=Display)
    trace_D__iz1 = StateMonitor(popD,'v',record=[0]) # iz1 (Type: Line:  scale=0.001 (dimensionless) timeScale=0.001 (dimensionless))

    # Display: Component(id=E type=Display)
    trace_E__iz1 = StateMonitor(popE,'v',record=[0]) # iz1 (Type: Line:  scale=0.001 (dimensionless) timeScale=0.001 (dimensionless))

# Saving to file: izfive_v.dat, reference: of0
record_of0__izA = StateMonitor(popA,'v',record=[0]) # izA (Type: OutputColumn)
record_of0__izB = StateMonitor(popB,'v',record=[0]) # izB (Type: OutputColumn)
record_of0__izC = StateMonitor(popC,'v',record=[0]) # izC (Type: OutputColumn)
record_of0__izD = StateMonitor(popD,'v',record=[0]) # izD (Type: OutputColumn)
record_of0__izE = StateMonitor(popE,'v',record=[0]) # izE (Type: OutputColumn)

print("Running simulation for %s (dt = %s, #steps = %s, code generation target = %s)"%(duration,defaultclock.dt, steps, prefs.codegen.target))
run(duration) # Run a simulation from t=0 to just before t=duration 
run(defaultclock.dt) # Run one more time step to allow saving the point at t=duration

# Saving to file: izfive_v.dat, reference: of0
all_of0 = np.array( [ record_of0__izA.t, record_of0__izA.v[0] , record_of0__izB.v[0] , record_of0__izC.v[0] , record_of0__izD.v[0] , record_of0__izE.v[0]  ] )
all_of0 = all_of0.transpose()
file_of0 = open("izfive_v.dat", 'w')
for l in all_of0:
    line = ''
    for c in l: 
        line = line + ('\t%s'%c if len(line)>0 else '%s'%c)
    file_of0.write(line+'\n')
file_of0.close()

if show_gui:

    import matplotlib.pyplot as plt

    # Display: Component(id=A type=Display)
    display_A = plt.figure("(A) tonic spiking")
    plot_iz1 = display_A.add_subplot(111, autoscale_on=True)
    plot_iz1.plot(trace_A__iz1.t/second,trace_A__iz1.v[0], color="#0000FF", label="iz1")
    plot_iz1.legend()

    # Display: Component(id=B type=Display)
    display_B = plt.figure("(B) phasic spiking")
    plot_iz1 = display_B.add_subplot(111, autoscale_on=True)
    plot_iz1.plot(trace_B__iz1.t/second,trace_B__iz1.v[0], color="#0000FF", label="iz1")
    plot_iz1.legend()

    # Display: Component(id=C type=Display)
    display_C = plt.figure("(C) tonic bursting")
    plot_iz1 = display_C.add_subplot(111, autoscale_on=True)
    plot_iz1.plot(trace_C__iz1.t/second,trace_C__iz1.v[0], color="#0000FF", label="iz1")
    plot_iz1.legend()

    # Display: Component(id=D type=Display)
    display_D = plt.figure("(D) phasic bursting")
    plot_iz1 = display_D.add_subplot(111, autoscale_on=True)
    plot_iz1.plot(trace_D__iz1.t/second,trace_D__iz1.v[0], color="#0000FF", label="iz1")
    plot_iz1.legend()

    # Display: Component(id=E type=Display)
    display_E = plt.figure("(E) mixed mode")
    plot_iz1 = display_E.add_subplot(111, autoscale_on=True)
    plot_iz1.plot(trace_E__iz1.t/second,trace_E__iz1.v[0], color="#0000FF", label="iz1")
    plot_iz1.legend()
    plt.show()
